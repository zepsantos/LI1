trabalhaDisparosCanhoes l 0 e = e {disparosEstado = catMaybes l}
trabalhaDisparosCanhoes l n e = if eDisparoCanhao getDisp then atingiu else trabalhaDisparosCanhoes l (n-1) e
                              where getDisp = encontraIndiceLista (n-1) l
                                    atingiu = if isJust existeDisp then trabalhaDisparosCanhoes newDisp (n-1) e else trabalhaDisparosCanhoes (atualizaIndiceLista (n-1) (Nothing) l2) (n-1) newEstado -- ESTA MAL AQUI ESTA A PERDER A LISTA DOS DISP
                                    newDisp = atualizaIndiceLista (n-1) (nextTickCanhao existeDisp) l
                                    (existeDisp,newEstado,l2) = checkAtingiu (fromJust getDisp) e
      

checkAcertouNumCanhao d e = if length (disparosEstado e) > length temp then (Nothing,e,disp) else (Just d,e,(disp))
                        where disp = acertouNumCanhao d (disparosEstado e) e
                              temp = catMaybes disp -- ESTA MAL AQUI

acertouNumCanhao _ [] e = []
acertouNumCanhao d (h@DisparoCanhao{jogadorDisparo = _, posicaoDisparo = pD , direcaoDisparo = _}:t) e = if h /= d && (pD == pos ||pD == somaVetores pos (direcaoParaVetor dir ))  then  Nothing:acertouNumCanhao d t e else (Just h):acertouNumCanhao d t e
                        where pos = posicaoDisparo d
                              pos1 = get2PosDisp (direcaoDisparo d) pos
                              dir = direcaoDisparo d


checkBateuNumaParede (Nothing,e,l) = (Nothing,e,l)
checkBateuNumaParede (Just d, e,l) = if estadoMudou e eTemp then  (disp,eTemp,l) else (disp,e,l)
                              where (eTemp,disp) = canhaoABaterNaParede d e  


canhaoABaterNaParede d e = if  encInd || encInd2 then (estado2,Nothing) else (estado,Just d)
               where mapa = mapaEstado e
                     pos1 = get2PosDisp (direcaoDisparo d) pos
                     pos =  posicaoDisparo d
                     peca p = encontraPosicaoMatriz p mapa
                     (estado,encInd)  =  verificaParede (peca pos) pos e
                     (estado2,encInd2) = verificaParede (peca pos1) pos1 estado  


estado
                  where estado = trabalhaDisparosCanhoes (listOfDisp) (length (disparosEstado e)-1) e
                        listOfDisp = map listaParaJust  (disparosEstado e)

-- | Passa um elemento (a) para um Just a
listaParaJust :: a -> Maybe a
listaParaJust a = Just a

-- | Percorre a lista dos Maybe Disparo e um int e vai acedendo atraves do indice , so no final elimina os disparos que foram elimados por bater noutros disparos
trabalhaDisparosCanhoes ::  [Maybe Disparo] -> Int -> Estado -> Estado
trabalhaDisparosCanhoes l 0 e = e {disparosEstado = catMaybes l}
trabalhaDisparosCanhoes l n e = if eDisparoCanhao disp then atingiu  else trabalhaDisparosCanhoes l (n-1) e
                              where disp = encontraIndiceLista n l
                                    atingiu = 
                                    (newDisp,newEstado,newl) = checkAtingiu disp e

     

-- | Verifica se o disparo bateu em alguma coisa                                  
checkAtingiu :: Disparo -> Estado -> (Maybe Disparo,Estado,[Maybe Disparo])
checkAtingiu d e = checkBateuNumaParede $ checkAcertouNumJogador $ checkAcertouNumCanhao d e

-- | Verifica se o disparo acertou noutro canhao , se o length (disparosEstado) > length temp entao houve alteracoes na lista de canhoes e portanto o disparo bateu em algum canhao
checkAcertouNumCanhao :: Disparo -> Estado -> (Maybe Disparo , Estado,[Maybe Disparo])

                               
-- | Verifica se o disparo Canhao acerta noutro Disparo Canhao
acertouNumCanhao :: Disparo -> [Disparo] -> Estado -> [Maybe Disparo]


-- | Verifica se o disparo (existe) e bate numa parede
checkBateuNumaParede :: (Maybe Disparo , Estado,[Maybe Disparo]) -> (Maybe Disparo , Estado,[Maybe Disparo])


-- | Verifica se o Canhao bate na parede                              
canhaoABaterNaParede :: Disparo -> Estado -> (Estado,Maybe Disparo)


-- | Verifica se o disparo Canhao acerta noutro Jogador
checkAcertouNumJogador :: (Maybe Disparo , Estado,[Maybe Disparo]) -> (Maybe Disparo , Estado,[Maybe Disparo])
checkAcertouNumJogador (Nothing,e,l) = (Nothing,e,l)
checkAcertouNumJogador (Just d, e,l) = if estadoMudou e eTemp then (Nothing,eTemp,l) else (Just d,e,l)
                              where eTemp = e{jogadoresEstado = acertouNumJogador (jogadoresEstado e) 0 d}

-- | Verifica se acerta nos jogadores que existem no jogo
acertouNumJogador :: [Jogador] -> Int -> Disparo -> [Jogador]
acertouNumJogador [] _ _ = []
acertouNumJogador (h:t) x disp = if x /= (jogadorDisparo disp) then atinge else  (if verificaSeDispRecente h disp then h:acertouNumJogador t (x+1) disp else atinge) {-Ve se a posicao de disparo coincide com a posicao em que o jogador dispararia-} 
                              where isHit = isJogadorHit (posTank h) (pos,pos1)
                                    pos = posicaoDisparo disp
                                    pos1 = get2PosDisp (direcaoDisparo disp) pos
                                    atinge = if isHit then h{vidasJogador = decreaseVidasJogador (vidasJogador h)}:acertouNumJogador t (x+1) disp else h:acertouNumJogador  t (x+1) disp
                                    
-- | Verifica se o jogador não acabou de disparar e portanto nao acerta nele
verificaSeDispRecente :: Jogador -> Disparo -> Bool
verificaSeDispRecente jog d = somaVetores (posicaoJogador jog) (direcaoParaVetor (direcaoJogador jog)) == (posicaoDisparo d) && (direcaoDisparo d) == (direcaoJogador jog)


-- | Verifica se o Jogador (4x4) é atingido pelo Disparo
isJogadorHit :: [Posicao] -> (Posicao,Posicao) -> Bool
isJogadorHit [] _ = False
isJogadorHit (h:t) (p1,p2) = if h == p1 || h == p2 then True else isJogadorHit t (p1,p2)    



-- | Avança o Canhao uma posição
nextTickCanhao :: Maybe Disparo -> Maybe Disparo
nextTickCanhao Nothing = Nothing
nextTickCanhao  (Just d) = Just d{posicaoDisparo = somaVetores (posicaoDisparo d) (direcaoParaVetor (direcaoDisparo d))}


-- | Verifica se o Estado Mudou
estadoMudou :: Estado -> Estado -> Bool
estadoMudou e e2 = e /= e2

-- | Retorna a segunda Posicao do Disparo
get2PosDisp :: Direcao -> Posicao -> Posicao
get2PosDisp C (x,y) = (x,y+1)
get2PosDisp B (x,y) = (x,y+1)
get2PosDisp D (x,y) = (x+1,y)
get2PosDisp E (x,y) = (x+1,y)





-- | Funcao que retorna uma lista de posiçoes dos tanques dos jogadores (4x4)
posTank :: Jogador -> [Posicao]
posTank jog = [(x,y),(x+1,y),(x+1,y+1),(x,y+1)]
            where (x,y) = posicaoJogador jog

-- | Funcao que tira vidas ao Jogador
decreaseVidasJogador :: Int -> Int
decreaseVidasJogador 0 = 0
decreaseVidasJogador n = n-1                            

-- | Funcao que verifica o tipo de parede e a destroi
verificaParede :: Peca -> Posicao -> Estado -> (Estado,Bool)
verificaParede (Bloco Destrutivel) pos estado = (estado{mapaEstado = atualizaPosicaoMatriz pos Vazia (mapaEstado estado)},True)
verificaParede (Vazia) _ e = (e,False)
verificaParede  _ _ estado = (estado,True)